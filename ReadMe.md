**2018-August**<br>

It is always good to push yourself to think hard and aim the optimal solution in terms of time complexity. Last Thursday I had chance to work on the algorithm called "construct a binary expression tree using infix expression" in 30 minutes. Since I do not take risk to go for the optimal solution using O(N) and stack data structure, I learn the lesson again. 

I like to start to put together 100 hard level algorithms practice and learning here. Those hard level algorithms change my life as a sofware programmer. I need to get organized and also strive to think more often for those hard level algorithms. 

A<br>
B<br>
C<br>

D<br>
Deletion distance

E<br>
F<br>
G<br>
H<br>

I <br>
Infix expression to binary expression tree

J<br>
K<br>
L<br>
M<br>
N<br>
O<br>

P<br>
Pigeon hole principle

Q<br>

R<br>
Regular expression matching

S<br>
Sliding window<br>
Sliding window maximum<br>
Sliding windows minimum<br>
Sudoku solver<br>

T<br>
U<br>
Union find algorithm and practice March 26, 2019 <br>
V<br>
W<br>
X<br>
Y<br>
Z<br>

**2019-03-26**<br>
It is so interesting to learn the lesson again. I have to spend more time to work on union find algorithm, since I could not find one copy of code called UnionFind class which is trustable. And secondly I do not get familiar with APIs. <br>
I need to memorize all APIs first. <br>
I need to learn how to analyze the time complexity as well. <br>
I need to practice to write a solution based on union find algorithm, and finish it in 45 minutes. <br>
I need to work on the algorithm once a week, once a month, or once a three months. <br>

